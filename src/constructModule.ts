import { root } from 'getroot';
import { BinaryFileMetadata, BinaryMetadata, instantiateBinary } from './binaryCache';
// @ts-ignore: TS4023
import { BinaryCacheMetadata, BinaryEndpointMetadata } from './binaryCache';
import { ENVIRONMENT } from './environment';
import { log } from './util/logger';

type StringMap = { [key: string]: any };

/**
 * Runtime generated by requiring module satisfies runtimeModuleType.
 * `initializeRuntime` is injected via `constructModule` for awaitable module initialization.
 */
interface AsmRuntimeType {
  initializeRuntime: (timeout?: number) => Promise<boolean>;
}

/**
 * @internal
 * Build stringmap object to be injected when creates runtime for asm module.
 * Modularized asm module generated via MODULARIZE=1 accepts object as its creation function allow to attach
 * properties. Using those, this function construct few essential convinient functions like awaitable runtime init.
 *
 * Note some init like exporting in-memory FS functions can't be achieved via module object but should rely on
 * preprocessor (https://github.com/kwonoj/docker-hunspell-wasm/blob/eba7781311b31028eefb8eb3e2457d11f294e076/preprocessor.js#L14-L27)
 * to access function-scope variables inside.
 *
 * @param {StringMap} value pre-constructed value to be used, or empty object {}.
 * @param {ENVIRONMENT} environment Running environment to determine to use node.js specific path resolve.
 * (.wasm, .mem) via fetch when initialize module in a browser environment.
 *
 * @returns {StringMap} Augmented object with prefilled interfaces.
 */
const constructModule = (value: StringMap,
                         environment: ENVIRONMENT,
                         metadata?: BinaryMetadata) => {
  const ret = {
    ...value,
    __asm_module_isInitialized__: false,
    onRuntimeInitialized: null,
    initializeRuntime: null,
    ENVIRONMENT: environment
  } as any;

  //export initializeRuntime interface for awaitable runtime initialization
  ret.initializeRuntime = (timeout: number = 3000) => {
    if (ret.__asm_module_isInitialized__) {
      return Promise.resolve(true);
    }

    return new Promise((resolve, _reject) => {
      const timeoutId = setTimeout(() => resolve(false), timeout);

      //trap out preamble `abort()` function to avoid too verbose exception details
      //but only for initialization phase. Other errors will be thrown by postamble.js.
      ret.onAbort = (reason: Error | any) => {
        if (!ret.__asm_module_isInitialized__) {
          clearTimeout(timeoutId);
          log(`initializeRuntime: failed to initialize module`, reason);
          throw reason instanceof Error ? reason : new Error(reason);
        }
      };

      ret.onRuntimeInitialized = () => {
        clearTimeout(timeoutId);
        ret.__asm_module_isInitialized__ = true;
        log(`initializeRuntime: successfully initialized module`);
        resolve(true);
      };
    });
  };

  //Wasm module have separate wasm binary file to load
  if (!!metadata) {
    log(`constructModule: construct custom binary file load for ${JSON.stringify(metadata)}`);
    const { name, version } = metadata;

    if (environment === ENVIRONMENT.NODE) {
      const locateDir = (metadata as BinaryFileMetadata).locationPath || __dirname;
      log(`constructModule: binaryEndpoint found, setting locateFile for loading wasm binary from ${locateDir}`);
      //tslint:disable-next-line:no-require-imports
      ret.locateFile = (fileName: string) => require('path').join(locateDir, fileName);
    }

    //Allow cache compiled binary results for browser environment where indexedDB is available
    //Note: this isn't orthogonal condition to node.js environment,
    //cause Electron can have node access in renderer process
    if (!!root.indexedDB && !!name && !!version) {
      ret.instantiateWasm = (importObject: any, cb: (instance: any) => void) => {
        instantiateBinary({ ...metadata, environment }, importObject)
          .then((resultObject) => cb(resultObject.instance),
          (reason: any) => log(`constructModule: failed to instantiate binary for cld3, bail out`, { reason }));

        //async instantiate should return empty dict immediately
        return {};
      };
    }
  }

  return ret as AsmRuntimeType;
};

export { StringMap, AsmRuntimeType, constructModule };
